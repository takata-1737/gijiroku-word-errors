<!DOCTYPE html>
<html lang="ja" xmlns:mso="urn:schemas-microsoft-com:office:office" xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è­°äº‹éŒ²å°‚é–€ç”¨èªä¿®æ­£ãƒ„ãƒ¼ãƒ«ï¼ˆæ‹¡å¼µç‰ˆï¼‰</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .section h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: #7f8c8d;
            font-size: 16px;
            border-bottom: 2px solid transparent;
        }
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
        }
        .file-input {
            margin: 10px 0;
        }
        .btn {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn-success {
            background-color: #27ae60;
        }
        .btn-success:hover {
            background-color: #229954;
        }
        .btn-warning {
            background-color: #f39c12;
        }
        .btn-warning:hover {
            background-color: #e67e22;
        }
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .changes-list {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .change-item {
            margin: 5px 0;
            padding: 8px;
            background-color: #e7f3ff;
            border-left: 4px solid #3498db;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .regex-change-item {
            background-color: #f0f8e7;
            border-left-color: #27ae60;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }
        .stat-number {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
        }
        .dictionary-item {
            display: flex;
            margin: 8px 0;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .dictionary-item input {
            margin: 0 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
        }
        .dictionary-item button {
            padding: 6px 12px;
            font-size: 14px;
        }
        .regex-rule-item {
            display: flex;
            margin: 8px 0;
            align-items: center;
            padding: 10px;
            background-color: #f0f8e7;
            border-radius: 5px;
        }
        .regex-rule-item input {
            margin: 0 5px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .regex-pattern {
            flex: 2;
        }
        .regex-replacement {
            flex: 1;
        }
        .regex-description {
            flex: 2;
            font-size: 12px;
            color: #666;
        }
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .preview-before, .preview-after {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .preview-before h4 {
            color: #e74c3c;
            margin-top: 0;
        }
        .preview-after h4 {
            color: #27ae60;
            margin-top: 0;
        }
        .highlight-change {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .settings-grid, .preview-section {
                grid-template-columns: 1fr;
            }
        }
    </style>

<!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:_dlc_DocId msdt:dt="string">UJFKJ6WYH6MZ-1204683370-2055793</mso:_dlc_DocId>
<mso:_dlc_DocIdItemGuid msdt:dt="string">e6def0d3-8dbd-4f63-bc37-d82ea8f601f2</mso:_dlc_DocIdItemGuid>
<mso:_dlc_DocIdUrl msdt:dt="string">https://nabunken.sharepoint.com/sites/S_Planning-and-Coordination/S_&#25991;&#21270;&#36001;&#24773;&#22577;&#30740;&#31350;&#23460;/_layouts/15/DocIdRedir.aspx?ID=UJFKJ6WYH6MZ-1204683370-2055793, UJFKJ6WYH6MZ-1204683370-2055793</mso:_dlc_DocIdUrl>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head>
<body>
    <div class="container">
        <h1>ğŸ“‹ è­°äº‹éŒ²å°‚é–€ç”¨èªä¿®æ­£ãƒ„ãƒ¼ãƒ«ï¼ˆæ‹¡å¼µç‰ˆï¼‰</h1>
        
        <!-- è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="section">
            <h3>âš™ï¸ ä¿®æ­£ãƒ«ãƒ¼ãƒ«è¨­å®š</h3>
            <div class="tabs">
                <button class="tab active" onclick="switchTab('dictionary')">ç”¨èªè¾æ›¸</button>
                <button class="tab" onclick="switchTab('regex')">æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«</button>
                <button class="tab" onclick="switchTab('normalization')">æ–‡å­—æ­£è¦åŒ–</button>
            </div>

            <!-- ç”¨èªè¾æ›¸ã‚¿ãƒ– -->
            <div id="dictionary" class="tab-content active">
                <div id="dictionary-list"></div>
                <div class="dictionary-item">
                    <input type="text" id="wrong-term" placeholder="é–“é•ã£ãŸç”¨èª">
                    <span>â†’</span>
                    <input type="text" id="correct-term" placeholder="æ­£ã—ã„ç”¨èª">
                    <button class="btn" onclick="addDictionaryEntry()">è¿½åŠ </button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-warning" onclick="loadDefaultDictionary()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¾æ›¸ã‚’èª­ã¿è¾¼ã¿</button>
                    <button class="btn" onclick="exportDictionary()">è¾æ›¸ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                    <input type="file" id="dict-file" accept=".json,.csv" style="display:none" onchange="importDictionary()">
                    <button class="btn" onclick="document.getElementById('dict-file').click()">è¾æ›¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                    <button class="btn btn-danger" onclick="clearDictionary()">è¾æ›¸ã‚’ã‚¯ãƒªã‚¢</button>
                </div>
            </div>

            <!-- æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚¿ãƒ– -->
            <div id="regex" class="tab-content">
                <div id="regex-rules-list"></div>
                <div class="regex-rule-item">
                    <input type="text" id="regex-pattern" placeholder="æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³" class="regex-pattern">
                    <input type="text" id="regex-replacement" placeholder="ç½®æ›æ–‡å­—" class="regex-replacement">
                    <input type="text" id="regex-description" placeholder="èª¬æ˜" class="regex-description">
                    <button class="btn" onclick="addRegexRule()">è¿½åŠ </button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-warning" onclick="loadDefaultRegexRules()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿</button>
                    <button class="btn btn-danger" onclick="clearRegexRules()">ãƒ«ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢</button>
                </div>
            </div>

            <!-- æ–‡å­—æ­£è¦åŒ–ã‚¿ãƒ– -->
            <div id="normalization" class="tab-content">
                <h4>é©ç”¨ã™ã‚‹æ­£è¦åŒ–å‡¦ç†ã‚’é¸æŠ:</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-katakana-length" checked>
                        <label for="normalize-katakana-length">ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€ï¼ˆãƒ¼ãƒ¼ãƒ¼ â†’ ãƒ¼ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-numbers" checked>
                        <label for="normalize-fullwidth-numbers">å…¨è§’æ•°å­—ã‚’åŠè§’ã«ï¼ˆï¼‘ï¼’ï¼“ â†’ 123ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-alpha" checked>
                        <label for="normalize-fullwidth-alpha">å…¨è§’è‹±å­—ã‚’åŠè§’ã«ï¼ˆï¼¡ï¼¢ï¼£ â†’ ABCï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-symbols" checked>
                        <label for="normalize-fullwidth-symbols">å…¨è§’è¨˜å·ã‚’åŠè§’ã«ï¼ˆï¼ï¼Ÿï¼ˆï¼‰ â†’ !?()ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-spaces" checked>
                        <label for="normalize-spaces">ã‚¹ãƒšãƒ¼ã‚¹çµ±ä¸€ï¼ˆå…¨è§’ãƒ»è¤‡æ•° â†’ åŠè§’å˜ä¸€ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-quotes" checked>
                        <label for="normalize-quotes">å¼•ç”¨ç¬¦çµ±ä¸€ï¼ˆ"" â†’ ""ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-dashes" checked>
                        <label for="normalize-dashes">ãƒ€ãƒƒã‚·ãƒ¥çµ±ä¸€ï¼ˆâ€•ï¼ â†’ -ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-katakana-variants" checked>
                        <label for="normalize-katakana-variants">ã‚«ã‚¿ã‚«ãƒŠè¡¨è¨˜çµ±ä¸€ï¼ˆãƒ´ã‚¡ â†’ ãƒï¼‰</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç† -->
        <div class="section">
            <h3>ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†</h3>
            <div class="file-input">
                <input type="file" id="file-input" multiple accept=".txt,.md" onchange="handleFileSelect()">
                <label for="file-input" class="btn">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
                <button class="btn btn-success" onclick="processAllFiles()">å…¨ãƒ•ã‚¡ã‚¤ãƒ«ä¸€æ‹¬å‡¦ç†</button>
            </div>
            <div id="file-list"></div>
        </div>

        <!-- ãƒ†ã‚­ã‚¹ãƒˆç›´æ¥å…¥åŠ› -->
        <div class="section">
            <h3>âœï¸ ãƒ†ã‚­ã‚¹ãƒˆç›´æ¥ä¿®æ­£</h3>
            <div class="preview-section">
                <div class="preview-before">
                    <h4>ä¿®æ­£å‰</h4>
                    <textarea id="input-text" placeholder="ä¿®æ­£ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
                </div>
                <div class="preview-after">
                    <h4>ä¿®æ­£å¾Œï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</h4>
                    <textarea id="preview-text" placeholder="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼..." readonly></textarea>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-success" onclick="correctText()">ä¿®æ­£å®Ÿè¡Œ</button>
                <button class="btn" onclick="clearText()">ã‚¯ãƒªã‚¢</button>
                <button class="btn" onclick="toggleAutoPreview()">è‡ªå‹•ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ ON/OFF</button>
            </div>
        </div>

        <!-- çµæœè¡¨ç¤º -->
        <div class="section">
            <h3>ğŸ“Š ä¿®æ­£çµæœ</h3>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-number" id="total-changes">0</div>
                    <div>ç·ä¿®æ­£æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="files-processed">0</div>
                    <div>å‡¦ç†ãƒ•ã‚¡ã‚¤ãƒ«æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="unique-corrections">0</div>
                    <div>ä¿®æ­£ç¨®é¡æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="regex-corrections">0</div>
                    <div>æ­£è¦åŒ–ä¿®æ­£æ•°</div>
                </div>
            </div>
            <div id="changes-display" class="changes-list" style="display:none;">
                <h4>ä¿®æ­£å†…å®¹:</h4>
                <div id="changes-list"></div>
            </div>
            <textarea id="output-text" placeholder="ä¿®æ­£ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™..." readonly></textarea>
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-success" onclick="downloadResult()" style="display:none;" id="download-btn">ä¿®æ­£çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                <button class="btn" onclick="copyToClipboard()">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</button>
            </div>
        </div>
    </div>

    <script>
        class AdvancedTerminologyCorrector {
            constructor() {
                this.correctionDict = new Map();
                this.regexRules = [];
                this.autoPreview = true;
                this.loadDefaultDictionary();
                this.loadDefaultRegexRules();
                this.updateDictionaryDisplay();
                this.updateRegexRulesDisplay();
                this.setupEventListeners();
            }

            setupEventListeners() {
                const inputText = document.getElementById('input-text');
                inputText.addEventListener('input', () => {
                    if (this.autoPreview) {
                        this.updatePreview();
                    }
                });
            }

            loadDefaultDictionary() {
                const defaultTerms = {
                    // ITç”¨èª
                    "ãƒ‡ãƒ¼ã‚¿ãƒ¼ãƒ™ãƒ¼ã‚¹": "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹",
                    "ã‚µãƒ¼ãƒãƒ¼": "ã‚µãƒ¼ãƒ",
                    "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼": "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿",
                    "ãƒ—ãƒªãƒ³ã‚¿ãƒ¼": "ãƒ—ãƒªãƒ³ã‚¿",
                    "ã‚¹ã‚­ãƒ£ãƒŠãƒ¼": "ã‚¹ã‚­ãƒ£ãƒŠ",
                    "ãƒ¦ãƒ¼ã‚¶ãƒ¼": "ãƒ¦ãƒ¼ã‚¶",
                    "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼": "ãƒãƒãƒ¼ã‚¸ãƒ£",
                    "ãƒ‡ãƒ™ãƒ­ãƒƒãƒ‘ãƒ¼": "ãƒ‡ãƒ™ãƒ­ãƒƒãƒ‘",
                    
                    // ãƒ“ã‚¸ãƒã‚¹ç”¨èª
                    "ã‚¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ“ãƒªãƒ†ã‚£ãƒ¼": "ã‚¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ“ãƒªãƒ†ã‚£",
                    "ãƒ—ãƒ©ã‚¤ã‚ªãƒªãƒ†ã‚£ãƒ¼": "ãƒ—ãƒ©ã‚¤ã‚ªãƒªãƒ†ã‚£",
                    "ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ¼": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£",
                    "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¼": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£",
                    "ã‚¯ã‚ªãƒªãƒ†ã‚£ãƒ¼": "ã‚¯ã‚ªãƒªãƒ†ã‚£",
                    
                    // ã‚ˆãã‚ã‚‹é–“é•ã„
                    "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ã‚¦": "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼",
                    "ãƒãƒ¼ãƒã‚¦": "ãƒã‚¦ãƒã‚¦",
                    "ã‚³ãƒŸãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³": "ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³",
                    "ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¼": "ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£",
                    "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼": "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£",
                    
                    // ç•¥èªã®çµ±ä¸€
                    "ï¼¡ï¼©": "AI",
                    "ï¼©ï½ï¼´": "IoT",
                    "ï¼©ï¼´": "IT",
                    "ï¼µï¼©": "UI",
                    "ï¼µï¼¸": "UX"
                };

                for (const [wrong, correct] of Object.entries(defaultTerms)) {
                    this.correctionDict.set(wrong, correct);
                }
            }

            loadDefaultRegexRules() {
                this.regexRules = [
                    {
                        pattern: 'ãƒ¼{2,}',
                        replacement: 'ãƒ¼',
                        description: 'ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€ï¼ˆè¤‡æ•°ã®é•·éŸ³ç¬¦ã‚’1ã¤ã«ï¼‰',
                        enabled: true
                    },
                    {
                        pattern: '[ï¼-ï¼™]',
                        replacement: (match) => String.fromCharCode(match.charCodeAt(0) - 0xFF10 + 0x30),
                        description: 'å…¨è§’æ•°å­—ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true
                    },
                    {
                        pattern: '[ï¼¡-ï¼ºï½-ï½š]',
                        replacement: (match) => String.fromCharCode(match.charCodeAt(0) - (match <= 'ï¼º' ? 0xFF21 : 0xFF41) + (match <= 'ï¼º' ? 0x41 : 0x61)),
                        description: 'å…¨è§’è‹±å­—ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true
                    },
                    {
                        pattern: '[ï¼ï¼Ÿï¼ˆï¼‰ï¼»ï¼½ï½›ï½ã€Œã€ã€ã€ï¼œï¼]',
                        replacement: (match) => {
                            const map = {
                                'ï¼': '!', 'ï¼Ÿ': '?', 'ï¼ˆ': '(', 'ï¼‰': ')',
                                'ï¼»': '[', 'ï¼½': ']', 'ï½›': '{', 'ï½': '}',
                                'ã€Œ': 'ã€Œ', 'ã€': 'ã€', 'ã€': 'ã€', 'ã€': 'ã€',
                                'ï¼œ': '<', 'ï¼': '>'
                            };
                            return map[match] || match;
                        },
                        description: 'å…¨è§’è¨˜å·ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true
                    },
                    {
                        pattern: 'ã€€+',
                        replacement: ' ',
                        description: 'å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã‚’åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ›',
                        enabled: true
                    },
                    {
                        pattern: ' {2,}',
                        replacement: ' ',
                        description: 'è¤‡æ•°ã®åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã‚’1ã¤ã«çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: '["""]',
                        replacement: '"',
                        description: 'å¼•ç”¨ç¬¦ã‚’çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: '[â€•ï¼â€]',
                        replacement: '-',
                        description: 'ãƒ€ãƒƒã‚·ãƒ¥è¨˜å·ã‚’çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: 'ãƒ´([ã‚¡-ã‚©])',
                        replacement: 'ãƒ$1',
                        description: 'ãƒ´ã‚¡è¡Œã‚’ãƒè¡Œã«å¤‰æ›',
                        enabled: false
                    }
                ];
            }

            addCorrection(wrongTerm, correctTerm) {
                if (wrongTerm && correctTerm) {
                    this.correctionDict.set(wrongTerm, correctTerm);
                    this.updateDictionaryDisplay();
                }
            }

            removeCorrection(wrongTerm) {
                this.correctionDict.delete(wrongTerm);
                this.updateDictionaryDisplay();
            }

            addRegexRule(pattern, replacement, description) {
                if (pattern && replacement && description) {
                    this.regexRules.push({
                        pattern,
                        replacement,
                        description,
                        enabled: true
                    });
                    this.updateRegexRulesDisplay();
                }
            }

            removeRegexRule(index) {
                this.regexRules.splice(index, 1);
                this.updateRegexRulesDisplay();
            }

            toggleRegexRule(index) {
                this.regexRules[index].enabled = !this.regexRules[index].enabled;
                this.updateRegexRulesDisplay();
            }

            correctText(text) {
                let correctedText = text;
                const changes = [];
                const regexChanges = [];

                // è¾æ›¸ã«ã‚ˆã‚‹ç½®æ›
                for (const [wrongTerm, correctTerm] of this.correctionDict) {
                    const regex = new RegExp(wrongTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    const matches = correctedText.match(regex);
                    if (matches) {
                        correctedText = correctedText.replace(regex, correctTerm);
                        changes.push({
                            wrong: wrongTerm,
                            correct: correctTerm,
                            count: matches.length
                        });
                    }
                }

                // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹ä¿®æ­£ï¼ˆæœ‰åŠ¹ãªã‚‚ã®ã®ã¿ï¼‰
                for (const rule of this.regexRules.filter(r => r.enabled)) {
                    const regex = new RegExp(rule.pattern, 'g');
                    const beforeCorrection = correctedText;
                    
                    if (typeof rule.replacement === 'function') {
                        correctedText = correctedText.replace(regex, rule.replacement);
                    } else {
                        correctedText = correctedText.replace(regex, rule.replacement);
                    }
                    
                    if (beforeCorrection !== correctedText) {
                        const matchCount = (beforeCorrection.match(regex) || []).length;
                        regexChanges.push({
                            description: rule.description,
                            pattern: rule.pattern,
                            count: matchCount
                        });
                    }
                }

                // æ–‡å­—æ­£è¦åŒ–å‡¦ç†
                const normalizationSettings = this.getNormalizationSettings();
                if (normalizationSettings.katakanaLength) {
                    const before = correctedText;
                    correctedText = correctedText.replace(/ãƒ¼{2,}/g, 'ãƒ¼');
                    if (before !== correctedText) {
                        regexChanges.push({
                            description: 'ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€',
                            pattern: 'ãƒ¼{2,}',
                            count: (before.match(/ãƒ¼{2,}/g) || []).length
                        });
                    }
                }

                return { correctedText, changes, regexChanges };
            }

            getNormalizationSettings() {
                return {
                    katakanaLength: document.getElementById('normalize-katakana-length').checked,
                    fullwidthNumbers: document.getElementById('normalize-fullwidth-numbers').checked,
                    fullwidthAlpha: document.getElementById('normalize-fullwidth-alpha').checked,
                    fullwidthSymbols: document.getElementById('normalize-fullwidth-symbols').checked,
                    spaces: document.getElementById('normalize-spaces').checked,
                    quotes: document.getElementById('normalize-quotes').checked,
                    dashes: document.getElementById('normalize-dashes').checked,
                    katakanaVariants: document.getElementById('normalize-katakana-variants').checked
                };
            }

            updatePreview() {
                const inputText = document.getElementById('input-text').value;
                if (inputText.trim()) {
                    const result = this.correctText(inputText);
                    document.getElementById('preview-text').value = result.correctedText;
                } else {
                    document.getElementById('preview-text').value = '';
                }
            }

            updateDictionaryDisplay() {
                const container = document.getElementById('dictionary-list');
                container.innerHTML = '';

                for (const [wrong, correct] of this.correctionDict) {
                    const item = document.createElement('div');
                    item.className = 'dictionary-item';
                    item.innerHTML = `
                        <input type="text" value="${wrong}" readonly>
                        <span>â†’</span>
                        <input type="text" value="${correct}" readonly>
                        <button class="btn btn-danger" onclick="corrector.removeCorrection('${wrong.replace(/'/g, "\\'")}')">å‰Šé™¤</button>
                    `;
                    container.appendChild(item);
                }
            }

            updateRegexRulesDisplay() {
                const container = document.getElementById('regex-rules-list');
                container.innerHTML = '';

                this.regexRules.forEach((rule, index) => {
                    const item = document.createElement('div');
                    item.className = 'regex-rule-item';
                    item.innerHTML = `
                        <input type="checkbox" ${rule.enabled ? 'checked' : ''} onchange="corrector.toggleRegexRule(${index})">
                        <input type="text" value="${rule.pattern}" readonly class="regex-pattern">
                        <input type="text" value="${typeof rule.replacement === 'function' ? '[Function]' : rule.replacement}" readonly class="regex-replacement">
                        <div class="regex-description">${rule.description}</div>
                        <button class="btn btn-danger" onclick="corrector.removeRegexRule(${index})">å‰Šé™¤</button>
                    `;
                    container.appendChild(item);
                });
            }

            exportDictionary() {
                const dict = Object.fromEntries(this.correctionDict);
                const exportData = {
                    dictionary: dict,
                    regexRules: this.regexRules.filter(rule => !rule.replacement.toString().includes('function'))
                };
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'terminology_settings.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            importDictionary(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (data.dictionary) {
                            for (const [wrong, correct] of Object.entries(data.dictionary)) {
                                this.correctionDict.set(wrong, correct);
                            }
                        }
                        
                        if (data.regexRules) {
                            this.regexRules = [...this.regexRules, ...data.regexRules];
                        }
                        
                        this.updateDictionaryDisplay();
                        this.updateRegexRulesDisplay();
                        alert('è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                    } catch (error) {
                        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“');
                    }
                };
                reader.readAsText(file);
            }
        }

        const corrector = new AdvancedTerminologyCorrector();
        let processedFiles = [];

        function switchTab(tabName) {
            // ã‚¿ãƒ–ã®åˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        function addDictionaryEntry() {
            const wrongTerm = document.getElementById('wrong-term').value.trim();
            const correctTerm = document.getElementById('correct-term').value.trim();
            
            if (wrongTerm && correctTerm) {
                corrector.addCorrection(wrongTerm, correctTerm);
                document.getElementById('wrong-term').value = '';
                document.getElementById('correct-term').value = '';
            } else {
                alert('ä¸¡æ–¹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        }

        function addRegexRule() {
            const pattern = document.getElementById('regex-pattern').value.trim();
            const replacement = document.getElementById('regex-replacement').value.trim();
            const description = document.getElementById('regex-description').value.trim();
            
            if (pattern && replacement && description) {
                corrector.addRegexRule(pattern, replacement, description);
                document.getElementById('regex-pattern').value = '';
                document.getElementById('regex-replacement').value = '';
                document.getElementById('regex-description').value = '';
            } else {
                alert('ã™ã¹ã¦ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        }

        function loadDefaultDictionary() {
            corrector.loadDefaultDictionary();
            corrector.updateDictionaryDisplay();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¾æ›¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        }

        function loadDefaultRegexRules() {
            corrector.loadDefaultRegexRules();
            corrector.updateRegexRulesDisplay();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        }

        function clearDictionary() {
            if (confirm('è¾æ›¸ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                corrector.correctionDict.clear();
                corrector.updateDictionaryDisplay();
            }
        }

        function clearRegexRules() {
            if (confirm('æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                corrector.regexRules = [];
                corrector.updateRegexRulesDisplay();
            }
        }

        function exportDictionary() {
            corrector.exportDictionary();
        }

        function importDictionary() {
            const file = document.getElementById('dict-file').files[0];
            if (file) {
                corrector.importDictionary(file);
            }
        }

        function handleFileSelect() {
            const files = document.getElementById('file-input').files;
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';

            Array.from(files).forEach((file, index) => {
                const item = document.createElement('div');
                item.style.cssText = 'margin: 10px 0; padding: 10px; background-color: #f8f9fa; border-radius: 5px;';
                item.innerHTML = `
                    <span style="font-weight: bold;">${file.name}</span>
                    <span style="color: #666; margin-left: 10px;">(${(file.size / 1024).toFixed(1)} KB)</span>
                    <button class="btn" onclick="processFile(${index})">å€‹åˆ¥å‡¦ç†</button>
                `;
                fileList.appendChild(item);
            });
        }

        function processFile(fileIndex) {
            const files = document.getElementById('file-input').files;
            const file = files[fileIndex];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = corrector.correctText(e.target.result);
                    document.getElementById('output-text').value = result.correctedText;
                    displayChanges(result.changes, result.regexChanges);
                    updateStats([...result.changes, ...result.regexChanges], 1, result.regexChanges.length);
                    document.getElementById('download-btn').style.display = 'inline-block';
                };
                reader.readAsText(file);
            }
        }

        function processAllFiles() {
            const files = document.getElementById('file-input').files;
            if (files.length === 0) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            let allResults = '';
            let totalChanges = [];
            let totalRegexChanges = [];
            let processedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = corrector.correctText(e.target.result);
                    allResults += `\n\n--- ${file.name} ---\n${result.correctedText}`;
                    totalChanges.push(...result.changes);
                    totalRegexChanges.push(...result.regexChanges);
                    processedCount++;

                    if (processedCount === files.length) {
                        document.getElementById('output-text').value = allResults;
                        displayChanges(totalChanges, totalRegexChanges);
                        updateStats([...totalChanges, ...totalRegexChanges], files.length, totalRegexChanges.length);
                        document.getElementById('download-btn').style.display = 'inline-block';
                    }
                };
                reader.readAsText(file);
            });
        }

        function correctText() {
            const inputText = document.getElementById('input-text').value;
            if (!inputText.trim()) {
                alert('ä¿®æ­£ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            const result = corrector.correctText(inputText);
            document.getElementById('output-text').value = result.correctedText;
            displayChanges(result.changes, result.regexChanges);
            updateStats([...result.changes, ...result.regexChanges], 1, result.regexChanges.length);
            document.getElementById('download-btn').style.display = 'inline-block';
        }

        function clearText() {
            document.getElementById('input-text').value = '';
            document.getElementById('output-text').value = '';
            document.getElementById('preview-text').value = '';
            document.getElementById('changes-display').style.display = 'none';
            updateStats([], 0, 0);
            document.getElementById('download-btn').style.display = 'none';
        }

        function toggleAutoPreview() {
            corrector.autoPreview = !corrector.autoPreview;
            const btn = event.target;
            btn.textContent = `è‡ªå‹•ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ ${corrector.autoPreview ? 'ON' : 'OFF'}`;
            btn.style.backgroundColor = corrector.autoPreview ? '#27ae60' : '#95a5a6';
        }

        function displayChanges(changes, regexChanges) {
            const changesContainer = document.getElementById('changes-display');
            const changesList = document.getElementById('changes-list');
            
            const totalChanges = changes.length + (regexChanges ? regexChanges.length : 0);
            
            if (totalChanges > 0) {
                changesContainer.style.display = 'block';
                changesList.innerHTML = '';
                
                // è¾æ›¸ã«ã‚ˆã‚‹ä¿®æ­£
                changes.forEach(change => {
                    const item = document.createElement('div');
                    item.className = 'change-item';
                    item.innerHTML = `<strong>${change.wrong}</strong> â†’ <strong>${change.correct}</strong> (${change.count}ç®‡æ‰€)`;
                    changesList.appendChild(item);
                });

                // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹ä¿®æ­£
                if (regexChanges) {
                    regexChanges.forEach(change => {
                        const item = document.createElement('div');
                        item.className = 'change-item regex-change-item';
                        item.innerHTML = `[æ­£è¦åŒ–] <strong>${change.description}</strong> (${change.count}ç®‡æ‰€)`;
                        changesList.appendChild(item);
                    });
                }
            } else {
                changesContainer.style.display = 'none';
            }
        }

        function updateStats(changes, fileCount, regexCount) {
            const totalChanges = changes.reduce((sum, change) => sum + (change.count || 1), 0);
            document.getElementById('total-changes').textContent = totalChanges;
            document.getElementById('files-processed').textContent = fileCount;
            document.getElementById('unique-corrections').textContent = changes.length;
            document.getElementById('regex-corrections').textContent = regexCount;
        }

        function downloadResult() {
            const result = document.getElementById('output-text').value;
            if (result) {
                const blob = new Blob([result], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'corrected_text.txt';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function copyToClipboard() {
            const result = document.getElementById('output-text').value;
            if (result) {
                navigator.clipboard.writeText(result).then(() => {
                    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                }).catch(() => {
                    alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
                });
            }
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            corrector.updatePreview();
        });
    </script>
</body>
</html>