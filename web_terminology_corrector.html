<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è­°äº‹éŒ²å°‚é–€ç”¨èªä¿®æ­£ãƒ„ãƒ¼ãƒ«ï¼ˆå®Œå…¨ç‰ˆï¼‰</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .section h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: #7f8c8d;
            font-size: 16px;
            border-bottom: 2px solid transparent;
        }
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
        }
        .file-input {
            margin: 10px 0;
        }
        .btn {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn-success {
            background-color: #27ae60;
        }
        .btn-success:hover {
            background-color: #229954;
        }
        .btn-warning {
            background-color: #f39c12;
        }
        .btn-warning:hover {
            background-color: #e67e22;
        }
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .changes-list {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .change-item {
            margin: 5px 0;
            padding: 8px;
            background-color: #e7f3ff;
            border-left: 4px solid #3498db;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .regex-change-item {
            background-color: #f0f8e7;
            border-left-color: #27ae60;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .stat-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }
        .stat-number {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
        }
        .dictionary-item {
            display: flex;
            margin: 8px 0;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .dictionary-item input {
            margin: 0 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
        }
        .dictionary-item button {
            padding: 6px 12px;
            font-size: 14px;
        }
        .regex-rule-item {
            display: flex;
            margin: 8px 0;
            align-items: center;
            padding: 10px;
            background-color: #f0f8e7;
            border-radius: 5px;
        }
        .regex-rule-item input {
            margin: 0 5px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .regex-pattern {
            flex: 2;
        }
        .regex-replacement {
            flex: 1;
        }
        .regex-description {
            flex: 2;
            font-size: 12px;
            color: #666;
        }
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .preview-before, .preview-after {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .preview-before h4 {
            color: #e74c3c;
            margin-top: 0;
        }
        .preview-after h4 {
            color: #27ae60;
            margin-top: 0;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .settings-grid, .preview-section {
                grid-template-columns: 1fr;
            }
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“‹ è­°äº‹éŒ²å°‚é–€ç”¨èªä¿®æ­£ãƒ„ãƒ¼ãƒ«ï¼ˆå®Œå…¨ç‰ˆï¼‰</h1>
        
        <!-- è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="section">
            <h3>âš™ï¸ ä¿®æ­£ãƒ«ãƒ¼ãƒ«è¨­å®š</h3>
            <div class="tabs">
                <button class="tab active" onclick="switchTab('dictionary')">ç”¨èªè¾æ›¸</button>
                <button class="tab" onclick="switchTab('regex')">æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«</button>
                <button class="tab" onclick="switchTab('normalization')">æ–‡å­—æ­£è¦åŒ–</button>
            </div>

            <!-- ç”¨èªè¾æ›¸ã‚¿ãƒ– -->
            <div id="dictionary" class="tab-content active">
                <div id="dictionary-list"></div>
                <div class="dictionary-item">
                    <input type="text" id="wrong-term" placeholder="é–“é•ã£ãŸç”¨èª">
                    <span>â†’</span>
                    <input type="text" id="correct-term" placeholder="æ­£ã—ã„ç”¨èª">
                    <button class="btn" onclick="addDictionaryEntry()">è¿½åŠ </button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-warning" onclick="loadDefaultDictionary()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¾æ›¸ã‚’èª­ã¿è¾¼ã¿</button>
                    <button class="btn" onclick="exportDictionary()">è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                    <input type="file" id="dict-file" accept=".json" style="display:none" onchange="importDictionary()">
                    <button class="btn" onclick="document.getElementById('dict-file').click()">JSONã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                    <input type="file" id="csv-file" accept=".csv,.tsv" style="display:none" onchange="importCSV()">
                    <button class="btn" onclick="document.getElementById('csv-file').click()">CSVã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                    <button class="btn" onclick="showJSONEditor()">JSONæ‰‹å‹•ä¿®æ­£</button>
                    <button class="btn btn-danger" onclick="clearDictionary()">è¾æ›¸ã‚’ã‚¯ãƒªã‚¢</button>
                </div>
            </div>

            <!-- æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚¿ãƒ– -->
            <div id="regex" class="tab-content">
                <div id="regex-rules-list"></div>
                <div class="regex-rule-item">
                    <input type="text" id="regex-pattern" placeholder="æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³" class="regex-pattern">
                    <input type="text" id="regex-replacement" placeholder="ç½®æ›æ–‡å­—" class="regex-replacement">
                    <input type="text" id="regex-description" placeholder="èª¬æ˜" class="regex-description">
                    <button class="btn" onclick="addRegexRule()">è¿½åŠ </button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-warning" onclick="loadDefaultRegexRules()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿</button>
                    <button class="btn btn-danger" onclick="clearRegexRules()">ãƒ«ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢</button>
                </div>
            </div>

            <!-- æ–‡å­—æ­£è¦åŒ–ã‚¿ãƒ– -->
            <div id="normalization" class="tab-content">
                <h4>é©ç”¨ã™ã‚‹æ­£è¦åŒ–å‡¦ç†ã‚’é¸æŠ:</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-katakana-length" checked>
                        <label for="normalize-katakana-length">ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€ï¼ˆãƒ¼ãƒ¼ãƒ¼ â†’ ãƒ¼ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-numbers" checked>
                        <label for="normalize-fullwidth-numbers">å…¨è§’æ•°å­—ã‚’åŠè§’ã«ï¼ˆï¼‘ï¼’ï¼“ â†’ 123ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-alpha" checked>
                        <label for="normalize-fullwidth-alpha">å…¨è§’è‹±å­—ã‚’åŠè§’ã«ï¼ˆï¼¡ï¼¢ï¼£ â†’ ABCï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-fullwidth-symbols" checked>
                        <label for="normalize-fullwidth-symbols">å…¨è§’è¨˜å·ã‚’åŠè§’ã«ï¼ˆï¼ï¼Ÿï¼ˆï¼‰ â†’ !?()ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-spaces" checked>
                        <label for="normalize-spaces">ã‚¹ãƒšãƒ¼ã‚¹çµ±ä¸€ï¼ˆå…¨è§’ãƒ»è¤‡æ•° â†’ åŠè§’å˜ä¸€ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-quotes" checked>
                        <label for="normalize-quotes">å¼•ç”¨ç¬¦çµ±ä¸€ï¼ˆ"" â†’ ""ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-dashes" checked>
                        <label for="normalize-dashes">ãƒ€ãƒƒã‚·ãƒ¥çµ±ä¸€ï¼ˆâ€•ï¼ â†’ -ï¼‰</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="normalize-katakana-variants" checked>
                        <label for="normalize-katakana-variants">ã‚«ã‚¿ã‚«ãƒŠè¡¨è¨˜çµ±ä¸€ï¼ˆãƒ´ã‚¡ â†’ ãƒï¼‰</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç† -->
        <div class="section">
            <h3>ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†</h3>
            <div class="file-input">
                <input type="file" id="file-input" multiple accept=".txt,.md" onchange="handleFileSelect()">
                <label for="file-input" class="btn">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
                <button class="btn btn-success" onclick="processAllFiles()">å…¨ãƒ•ã‚¡ã‚¤ãƒ«ä¸€æ‹¬å‡¦ç†</button>
            </div>
            <div id="file-list"></div>
        </div>

        <!-- ãƒ†ã‚­ã‚¹ãƒˆç›´æ¥å…¥åŠ› -->
        <div class="section">
            <h3>âœï¸ ãƒ†ã‚­ã‚¹ãƒˆç›´æ¥ä¿®æ­£</h3>
            <div class="preview-section">
                <div class="preview-before">
                    <h4>ä¿®æ­£å‰</h4>
                    <textarea id="input-text" placeholder="ä¿®æ­£ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
                </div>
                <div class="preview-after">
                    <h4>ä¿®æ­£å¾Œï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</h4>
                    <textarea id="preview-text" placeholder="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼..." readonly></textarea>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-success" onclick="correctText()">ä¿®æ­£å®Ÿè¡Œ</button>
                <button class="btn" onclick="clearText()">ã‚¯ãƒªã‚¢</button>
                <button class="btn" onclick="toggleAutoPreview()" id="preview-toggle">è‡ªå‹•ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ ON</button>
            </div>
        </div>

        <!-- çµæœè¡¨ç¤º -->
        <div class="section">
            <h3>ğŸ“Š ä¿®æ­£çµæœ</h3>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-number" id="total-changes">0</div>
                    <div>ç·ä¿®æ­£æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="files-processed">0</div>
                    <div>å‡¦ç†ãƒ•ã‚¡ã‚¤ãƒ«æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="unique-corrections">0</div>
                    <div>ä¿®æ­£ç¨®é¡æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="regex-corrections">0</div>
                    <div>æ­£è¦åŒ–ä¿®æ­£æ•°</div>
                </div>
            </div>
            <div id="changes-display" class="changes-list" style="display:none;">
                <h4>ä¿®æ­£å†…å®¹:</h4>
                <div id="changes-list"></div>
            </div>
            <textarea id="output-text" placeholder="ä¿®æ­£ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™..." readonly></textarea>
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-success" onclick="downloadResult()" style="display:none;" id="download-btn">ä¿®æ­£çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                <button class="btn" onclick="copyToClipboard()">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</button>
            </div>
        </div>
    </div>

    <script>
        class AdvancedTerminologyCorrector {
            constructor() {
                this.correctionDict = new Map();
                this.regexRules = [];
                this.autoPreview = true;
                this.loadDefaultDictionary();
                this.loadDefaultRegexRules();
                this.updateDictionaryDisplay();
                this.updateRegexRulesDisplay();
                this.setupEventListeners();
            }

            setupEventListeners() {
                const inputText = document.getElementById('input-text');
                inputText.addEventListener('input', () => {
                    if (this.autoPreview) {
                        this.updatePreview();
                    }
                });
            }

            loadDefaultDictionary() {
                const defaultTerms = {
                    // ITç”¨èª
                    "ãƒ‡ãƒ¼ã‚¿ãƒ¼ãƒ™ãƒ¼ã‚¹": "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹",
                    "ã‚µãƒ¼ãƒãƒ¼": "ã‚µãƒ¼ãƒ",
                    "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼": "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿",
                    "ãƒ—ãƒªãƒ³ã‚¿ãƒ¼": "ãƒ—ãƒªãƒ³ã‚¿",
                    "ã‚¹ã‚­ãƒ£ãƒŠãƒ¼": "ã‚¹ã‚­ãƒ£ãƒŠ",
                    "ãƒ¦ãƒ¼ã‚¶ãƒ¼": "ãƒ¦ãƒ¼ã‚¶",
                    "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼": "ãƒãƒãƒ¼ã‚¸ãƒ£",
                    "ãƒ‡ãƒ™ãƒ­ãƒƒãƒ‘ãƒ¼": "ãƒ‡ãƒ™ãƒ­ãƒƒãƒ‘",
                    
                    // ãƒ“ã‚¸ãƒã‚¹ç”¨èª
                    "ã‚¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ“ãƒªãƒ†ã‚£ãƒ¼": "ã‚¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ“ãƒªãƒ†ã‚£",
                    "ãƒ—ãƒ©ã‚¤ã‚ªãƒªãƒ†ã‚£ãƒ¼": "ãƒ—ãƒ©ã‚¤ã‚ªãƒªãƒ†ã‚£",
                    "ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ¼": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£",
                    "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¼": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£",
                    "ã‚¯ã‚ªãƒªãƒ†ã‚£ãƒ¼": "ã‚¯ã‚ªãƒªãƒ†ã‚£",
                    
                    // ã‚ˆãã‚ã‚‹é–“é•ã„
                    "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ã‚¦": "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼",
                    "ãƒãƒ¼ãƒã‚¦": "ãƒã‚¦ãƒã‚¦",
                    "ã‚³ãƒŸãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³": "ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³",
                    "ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¼": "ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£",
                    "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼": "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£",
                    
                    // ç•¥èªã®çµ±ä¸€
                    "ï¼¡ï¼©": "AI",
                    "ï¼©ï½ï¼´": "IoT",
                    "ï¼©ï¼´": "IT",
                    "ï¼µï¼©": "UI",
                    "ï¼µï¼¸": "UX"
                };

                for (const [wrong, correct] of Object.entries(defaultTerms)) {
                    this.correctionDict.set(wrong, correct);
                }
            }

            loadDefaultRegexRules() {
                this.regexRules = [
                    {
                        pattern: 'ãƒ¼{2,}',
                        replacement: 'ãƒ¼',
                        description: 'ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€ï¼ˆè¤‡æ•°ã®é•·éŸ³ç¬¦ã‚’1ã¤ã«ï¼‰',
                        enabled: true
                    },
                    {
                        pattern: '[ï¼-ï¼™]',
                        replacement: '[FUNCTION]',
                        description: 'å…¨è§’æ•°å­—ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true,
                        replacementFunction: (match) => String.fromCharCode(match.charCodeAt(0) - 0xFF10 + 0x30)
                    },
                    {
                        pattern: '[ï¼¡-ï¼ºï½-ï½š]',
                        replacement: '[FUNCTION]',
                        description: 'å…¨è§’è‹±å­—ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true,
                        replacementFunction: (match) => String.fromCharCode(match.charCodeAt(0) - (match <= 'ï¼º' ? 0xFF21 : 0xFF41) + (match <= 'ï¼º' ? 0x41 : 0x61))
                    },
                    {
                        pattern: '[ï¼ï¼Ÿï¼ˆï¼‰ï¼»ï¼½ï½›ï½ï¼œï¼]',
                        replacement: '[FUNCTION]',
                        description: 'å…¨è§’è¨˜å·ã‚’åŠè§’ã«å¤‰æ›',
                        enabled: true,
                        replacementFunction: (match) => {
                            const map = {
                                'ï¼': '!', 'ï¼Ÿ': '?', 'ï¼ˆ': '(', 'ï¼‰': ')',
                                'ï¼»': '[', 'ï¼½': ']', 'ï½›': '{', 'ï½': '}',
                                'ï¼œ': '<', 'ï¼': '>'
                            };
                            return map[match] || match;
                        }
                    },
                    {
                        pattern: 'ã€€+',
                        replacement: ' ',
                        description: 'å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã‚’åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ›',
                        enabled: true
                    },
                    {
                        pattern: ' {2,}',
                        replacement: ' ',
                        description: 'è¤‡æ•°ã®åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã‚’1ã¤ã«çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: '["""]',
                        replacement: '"',
                        description: 'å¼•ç”¨ç¬¦ã‚’çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: '[â€•ï¼â€]',
                        replacement: '-',
                        description: 'ãƒ€ãƒƒã‚·ãƒ¥è¨˜å·ã‚’çµ±ä¸€',
                        enabled: true
                    },
                    {
                        pattern: 'ãƒ´([ã‚¡-ã‚©])',
                        replacement: 'ãƒ$1',
                        description: 'ãƒ´ã‚¡è¡Œã‚’ãƒè¡Œã«å¤‰æ›',
                        enabled: false
                    }
                ];
            }

            addCorrection(wrongTerm, correctTerm) {
                if (wrongTerm && correctTerm) {
                    this.correctionDict.set(wrongTerm, correctTerm);
                    this.updateDictionaryDisplay();
                }
            }

            removeCorrection(wrongTerm) {
                this.correctionDict.delete(wrongTerm);
                this.updateDictionaryDisplay();
            }

            addRegexRule(pattern, replacement, description) {
                if (pattern && replacement && description) {
                    this.regexRules.push({
                        pattern,
                        replacement,
                        description,
                        enabled: true
                    });
                    this.updateRegexRulesDisplay();
                }
            }

            removeRegexRule(index) {
                this.regexRules.splice(index, 1);
                this.updateRegexRulesDisplay();
            }

            toggleRegexRule(index) {
                this.regexRules[index].enabled = !this.regexRules[index].enabled;
                this.updateRegexRulesDisplay();
            }

            correctText(text) {
                let correctedText = text;
                const changes = [];
                const regexChanges = [];

                // è¾æ›¸ã«ã‚ˆã‚‹ç½®æ›
                for (const [wrongTerm, correctTerm] of this.correctionDict) {
                    const regex = new RegExp(wrongTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    const matches = correctedText.match(regex);
                    if (matches) {
                        correctedText = correctedText.replace(regex, correctTerm);
                        changes.push({
                            wrong: wrongTerm,
                            correct: correctTerm,
                            count: matches.length
                        });
                    }
                }

                // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹ä¿®æ­£ï¼ˆæœ‰åŠ¹ãªã‚‚ã®ã®ã¿ï¼‰
                for (const rule of this.regexRules.filter(r => r.enabled)) {
                    const regex = new RegExp(rule.pattern, 'g');
                    const beforeCorrection = correctedText;
                    
                    if (rule.replacementFunction) {
                        correctedText = correctedText.replace(regex, rule.replacementFunction);
                    } else {
                        correctedText = correctedText.replace(regex, rule.replacement);
                    }
                    
                    if (beforeCorrection !== correctedText) {
                        const matchCount = (beforeCorrection.match(regex) || []).length;
                        regexChanges.push({
                            description: rule.description,
                            pattern: rule.pattern,
                            count: matchCount
                        });
                    }
                }

                return { correctedText, changes, regexChanges };
            }

            getNormalizationSettings() {
                return {
                    katakanaLength: document.getElementById('normalize-katakana-length')?.checked || false,
                    fullwidthNumbers: document.getElementById('normalize-fullwidth-numbers')?.checked || false,
                    fullwidthAlpha: document.getElementById('normalize-fullwidth-alpha')?.checked || false,
                    fullwidthSymbols: document.getElementById('normalize-fullwidth-symbols')?.checked || false,
                    spaces: document.getElementById('normalize-spaces')?.checked || false,
                    quotes: document.getElementById('normalize-quotes')?.checked || false,
                    dashes: document.getElementById('normalize-dashes')?.checked || false,
                    katakanaVariants: document.getElementById('normalize-katakana-variants')?.checked || false
                };
            }

            updatePreview() {
                const inputText = document.getElementById('input-text').value;
                if (inputText.trim()) {
                    const result = this.correctText(inputText);
                    document.getElementById('preview-text').value = result.correctedText;
                } else {
                    document.getElementById('preview-text').value = '';
                }
            }

            updateDictionaryDisplay() {
                const container = document.getElementById('dictionary-list');
                container.innerHTML = '';

                for (const [wrong, correct] of this.correctionDict) {
                    const item = document.createElement('div');
                    item.className = 'dictionary-item';
                    const escapedWrong = wrong.replace(/'/g, "\\'").replace(/"/g, '\\"');
                    item.innerHTML = `
                        <input type="text" value="${wrong}" readonly>
                        <span>â†’</span>
                        <input type="text" value="${correct}" readonly>
                        <button class="btn btn-danger" onclick="corrector.removeCorrection('${escapedWrong}')">å‰Šé™¤</button>
                    `;
                    container.appendChild(item);
                }
            }

            updateRegexRulesDisplay() {
                const container = document.getElementById('regex-rules-list');
                container.innerHTML = '';

                this.regexRules.forEach((rule, index) => {
                    const item = document.createElement('div');
                    item.className = 'regex-rule-item';
                    const displayReplacement = rule.replacementFunction ? '[Function]' : rule.replacement;
                    item.innerHTML = `
                        <input type="checkbox" ${rule.enabled ? 'checked' : ''} onchange="corrector.toggleRegexRule(${index})">
                        <input type="text" value="${rule.pattern}" readonly class="regex-pattern">
                        <input type="text" value="${displayReplacement}" readonly class="regex-replacement">
                        <div class="regex-description">${rule.description}</div>
                        <button class="btn btn-danger" onclick="corrector.removeRegexRule(${index})">å‰Šé™¤</button>
                    `;
                    container.appendChild(item);
                });
            }

            exportDictionary() {
                try {
                    const dict = {};
                    for (const [key, value] of this.correctionDict) {
                        dict[key] = value;
                    }
                    
                    const exportableRegexRules = this.regexRules.map(rule => ({
                        pattern: rule.pattern,
                        replacement: rule.replacementFunction ? '[FUNCTION]' : rule.replacement,
                        description: rule.description,
                        enabled: rule.enabled
                    }));
                    
                    const exportData = {
                        dictionary: dict,
                        regexRules: exportableRegexRules,
                        exportDate: new Date().toISOString()
                    };
                    
                    const jsonString = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `terminology_settings_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    alert('è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                } catch (error) {
                    console.error('Export error:', error);
                    alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }

            importDictionary(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        let content = e.target.result;
                        
                        // JSONã®åŸºæœ¬çš„ãªä¿®æ­£ã‚’è©¦è¡Œ
                        content = this.fixCommonJSONErrors(content);
                        
                        const data = JSON.parse(content);
                        
                        if (data.dictionary) {
                            let importCount = 0;
                            for (const [wrong, correct] of Object.entries(data.dictionary)) {
                                if (wrong && wrong.trim() && correct && correct.trim()) {
                                    this.correctionDict.set(wrong.trim(), correct.trim());
                                    importCount++;
                                }
                            }
                            alert(`è¾æ›¸ã‹ã‚‰${importCount}ä»¶ã®ç”¨èªã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`);
                        }
                        
                        if (data.regexRules) {
                            const validRules = data.regexRules.filter(rule => 
                                rule.pattern && rule.description
                            );
                            this.regexRules = [...this.regexRules, ...validRules];
                            if (validRules.length > 0) {
                                alert(`${validRules.length}ä»¶ã®æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`);
                            }
                        }
                        
                        this.updateDictionaryDisplay();
                        this.updateRegexRulesDisplay();
                        
                    } catch (error) {
                        this.showImportError(error, e.target.result);
                    }
                };
                reader.readAsText(file, 'UTF-8');
            }

            fixCommonJSONErrors(jsonString) {
                let fixed = jsonString;
                
                // è¡Œæœ«ã®ã‚«ãƒ³ãƒä¸è¶³ã‚’ä¿®æ­£
                fixed = fixed.replace(/"\s*\n\s*"/g, '",\n  "');
                
                // æœ€å¾Œã®é …ç›®ã®ä½™åˆ†ãªã‚«ãƒ³ãƒã‚’å‰Šé™¤
                fixed = fixed.replace(/,(\s*[}\]])/g, '$1');
                
                // é‡è¤‡ã™ã‚‹ã‚«ãƒ³ãƒã‚’å‰Šé™¤
                fixed = fixed.replace(/,\s*,/g, ',');
                
                return fixed;
            }

            showImportError(error, originalContent) {
                const errorModal = document.createElement('div');
                errorModal.className = 'modal';
                errorModal.innerHTML = `
                    <div class="modal-content">
                        <h3 style="color: #e74c3c; margin-top: 0;">JSONèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</h3>
                        <p><strong>ã‚¨ãƒ©ãƒ¼:</strong> ${error.message}</p>
                        <div style="margin: 20px 0;">
                            <button class="btn" onclick="this.closest('.modal').remove()">é–‰ã˜ã‚‹</button>
                            <button class="btn btn-warning" onclick="window.tryAutoFix('${btoa(originalContent)}')">è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ</button>
                            <button class="btn" onclick="window.showJSONContent('${btoa(originalContent)}')">ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’è¡¨ç¤º</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(errorModal);
                
                window.tryAutoFix = (encodedContent) => {
                    try {
                        const content = atob(encodedContent);
                        const fixed = this.fixCommonJSONErrors(content);
                        const data = JSON.parse(fixed);
                        
                        if (data.dictionary) {
                            let count = 0;
                            for (const [wrong, correct] of Object.entries(data.dictionary)) {
                                if (wrong && wrong.trim() && correct && correct.trim()) {
                                    this.correctionDict.set(wrong.trim(), correct.trim());
                                    count++;
                                }
                            }
                            this.updateDictionaryDisplay();
                            errorModal.remove();
                            alert(`è‡ªå‹•ä¿®æ­£æˆåŠŸï¼${count}ä»¶ã®ç”¨èªã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`);
                        }
                    } catch (e) {
                        alert('è‡ªå‹•ä¿®æ­£ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
                    }
                };
                
                window.showJSONContent = (encodedContent) => {
                    const content = atob(encodedContent);
                    const contentModal = document.createElement('div');
                    contentModal.className = 'modal';
                    contentModal.innerHTML = `
                        <div class="modal-content">
                            <h3>ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹</h3>
                            <textarea readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px;">${content}</textarea>
                            <button class="btn" onclick="this.closest('.modal').remove()">é–‰ã˜ã‚‹</button>
                        </div>
                    `;
                    document.body.appendChild(contentModal);
                };
            }
        }

        const corrector = new AdvancedTerminologyCorrector();

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        function addDictionaryEntry() {
            const wrongTerm = document.getElementById('wrong-term').value.trim();
            const correctTerm = document.getElementById('correct-term').value.trim();
            
            if (wrongTerm && correctTerm) {
                corrector.addCorrection(wrongTerm, correctTerm);
                document.getElementById('wrong-term').value = '';
                document.getElementById('correct-term').value = '';
            } else {
                alert('ä¸¡æ–¹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        }

        function addRegexRule() {
            const pattern = document.getElementById('regex-pattern').value.trim();
            const replacement = document.getElementById('regex-replacement').value.trim();
            const description = document.getElementById('regex-description').value.trim();
            
            if (pattern && replacement && description) {
                corrector.addRegexRule(pattern, replacement, description);
                document.getElementById('regex-pattern').value = '';
                document.getElementById('regex-replacement').value = '';
                document.getElementById('regex-description').value = '';
            } else {
                alert('ã™ã¹ã¦ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        }

        function loadDefaultDictionary() {
            corrector.loadDefaultDictionary();
            corrector.updateDictionaryDisplay();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¾æ›¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        }

        function loadDefaultRegexRules() {
            corrector.loadDefaultRegexRules();
            corrector.updateRegexRulesDisplay();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        }

        function clearDictionary() {
            if (confirm('è¾æ›¸ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                corrector.correctionDict.clear();
                corrector.updateDictionaryDisplay();
            }
        }

        function clearRegexRules() {
            if (confirm('æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                corrector.regexRules = [];
                corrector.updateRegexRulesDisplay();
            }
        }

        function exportDictionary() {
            corrector.exportDictionary();
        }

        function importDictionary() {
            const file = document.getElementById('dict-file').files[0];
            if (file) {
                corrector.importDictionary(file);
            }
        }

        function importCSV() {
            const file = document.getElementById('csv-file').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        const lines = content.split('\n');
                        let importCount = 0;
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                let wrong, correct;
                                
                                if (line.includes('\t')) {
                                    [wrong, correct] = line.split('\t');
                                } else if (line.includes(',')) {
                                    [wrong, correct] = line.split(',');
                                } else {
                                    continue;
                                }
                                
                                if (wrong && correct) {
                                    wrong = wrong.replace(/^["']|["']$/g, '').trim();
                                    correct = correct.replace(/^["']|["']$/g, '').trim();
                                    
                                    if (wrong && correct) {
                                        corrector.addCorrection(wrong, correct);
                                        importCount++;
                                    }
                                }
                            }
                        }
                        
                        alert(`CSVã‹ã‚‰${importCount}ä»¶ã®ç”¨èªã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`);
                    } catch (error) {
                        alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                    }
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        function showJSONEditor() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            
            const sampleJSON = {
                "dictionary": {
                    "ãƒ‡ãƒ¼ã‚¿ãƒ¼ãƒ™ãƒ¼ã‚¹": "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹",
                    "ã‚µãƒ¼ãƒãƒ¼": "ã‚µãƒ¼ãƒ",
                    "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼": "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿"
                },
                "regexRules": [
                    {
                        "pattern": "ãƒ¼{2,}",
                        "replacement": "ãƒ¼",
                        "description": "ã‚«ã‚¿ã‚«ãƒŠé•·éŸ³ç¬¦çµ±ä¸€",
                        "enabled": true
                    }
                ]
            };
            
            modal.innerHTML = `
                <div class="modal-content">
                    <h3>JSONæ‰‹å‹•ä¿®æ­£</h3>
                    <p>ä¸‹è¨˜ã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã§JSONã‚’ä¿®æ­£ã—ã€ã€Œé©ç”¨ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
                    <textarea id="json-editor" style="width: 100%; height: 400px; font-family: monospace; font-size: 12px;" placeholder="JSONã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„...">${JSON.stringify(sampleJSON, null, 2)}</textarea>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-success" onclick="applyJSONEdit()">é©ç”¨</button>
                        <button class="btn" onclick="validateJSON()">æ§‹æ–‡ãƒã‚§ãƒƒã‚¯</button>
                        <button class="btn" onclick="this.closest('.modal').remove()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    </div>
                    <div id="json-status" style="margin-top: 10px; display: none;"></div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            window.validateJSON = () => {
                const content = document.getElementById('json-editor').value;
                const status = document.getElementById('json-status');
                
                try {
                    JSON.parse(content);
                    status.className = 'status-success';
                    status.style.display = 'block';
                    status.textContent = 'âœ“ JSONæ§‹æ–‡ã¯æ­£ã—ã„ã§ã™';
                } catch (error) {
                    status.className = 'status-error';
                    status.style.display = 'block';
                    status.textContent = `âœ— JSONã‚¨ãƒ©ãƒ¼: ${error.message}`;
                }
            };
            
            window.applyJSONEdit = () => {
                const content = document.getElementById('json-editor').value;
                
                try {
                    const data = JSON.parse(content);
                    
                    if (data.dictionary) {
                        let count = 0;
                        for (const [wrong, correct] of Object.entries(data.dictionary)) {
                            if (wrong && wrong.trim() && correct && correct.trim()) {
                                corrector.correctionDict.set(wrong.trim(), correct.trim());
                                count++;
                            }
                        }
                        corrector.updateDictionaryDisplay();
                        alert(`${count}ä»¶ã®ç”¨èªã‚’é©ç”¨ã—ã¾ã—ãŸ`);
                    }
                    
                    if (data.regexRules) {
                        const validRules = data.regexRules.filter(rule => 
                            rule.pattern && rule.description
                        );
                        corrector.regexRules = [...corrector.regexRules, ...validRules];
                        corrector.updateRegexRulesDisplay();
                        
                        if (validRules.length > 0) {
                            alert(`${validRules.length}ä»¶ã®æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¾ã—ãŸ`);
                        }
                    }
                    
                    modal.remove();
                } catch (error) {
                    const status = document.getElementById('json-status');
                    status.className = 'status-error';
                    status.style.display = 'block';
                    status.textContent = `âœ— é©ç”¨ã‚¨ãƒ©ãƒ¼: ${error.message}`;
                }
            };
        }

        function handleFileSelect() {
            const files = document.getElementById('file-input').files;
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';

            Array.from(files).forEach((file, index) => {
                const item = document.createElement('div');
                item.style.cssText = 'margin: 10px 0; padding: 10px; background-color: #f8f9fa; border-radius: 5px;';
                item.innerHTML = `
                    <span style="font-weight: bold;">${file.name}</span>
                    <span style="color: #666; margin-left: 10px;">(${(file.size / 1024).toFixed(1)} KB)</span>
                    <button class="btn" onclick="processFile(${index})">å€‹åˆ¥å‡¦ç†</button>
                `;
                fileList.appendChild(item);
            });
        }

        function processFile(fileIndex) {
            const files = document.getElementById('file-input').files;
            const file = files[fileIndex];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = corrector.correctText(e.target.result);
                    document.getElementById('output-text').value = result.correctedText;
                    displayChanges(result.changes, result.regexChanges);
                    updateStats([...result.changes, ...result.regexChanges], 1, result.regexChanges.length);
                    document.getElementById('download-btn').style.display = 'inline-block';
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        function processAllFiles() {
            const files = document.getElementById('file-input').files;
            if (files.length === 0) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            let allResults = '';
            let totalChanges = [];
            let totalRegexChanges = [];
            let processedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const result = corrector.correctText(e.target.result);
                    allResults += `\n\n--- ${file.name} ---\n${result.correctedText}`;
                    totalChanges.push(...result.changes);
                    totalRegexChanges.push(...result.regexChanges);
                    processedCount++;

                    if (processedCount === files.length) {
                        document.getElementById('output-text').value = allResults;
                        displayChanges(totalChanges, totalRegexChanges);
                        updateStats([...totalChanges, ...totalRegexChanges], files.length, totalRegexChanges.length);
                        document.getElementById('download-btn').style.display = 'inline-block';
                    }
                };
                reader.readAsText(file, 'UTF-8');
            });
        }

        function correctText() {
            const inputText = document.getElementById('input-text').value;
            if (!inputText.trim()) {
                alert('ä¿®æ­£ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            const result = corrector.correctText(inputText);
            document.getElementById('output-text').value = result.correctedText;
            displayChanges(result.changes, result.regexChanges);
            updateStats([...result.changes, ...result.regexChanges], 1, result.regexChanges.length);
            document.getElementById('download-btn').style.display = 'inline-block';
        }

        function clearText() {
            document.getElementById('input-text').value = '';
            document.getElementById('output-text').value = '';
            document.getElementById('preview-text').value = '';
            document.getElementById('changes-display').style.display = 'none';
            updateStats([], 0, 0);
            document.getElementById('download-btn').style.display = 'none';
        }

        function toggleAutoPreview() {
            corrector.autoPreview = !corrector.autoPreview;
            const btn = document.getElementById('preview-toggle');
            btn.textContent = `è‡ªå‹•ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ ${corrector.autoPreview ? 'ON' : 'OFF'}`;
            btn.style.backgroundColor = corrector.autoPreview ? '#27ae60' : '#95a5a6';
        }

        function displayChanges(changes, regexChanges) {
            const changesContainer = document.getElementById('changes-display');
            const changesList = document.getElementById('changes-list');
            
            const totalChanges = changes.length + (regexChanges ? regexChanges.length : 0);
            
            if (totalChanges > 0) {
                changesContainer.style.display = 'block';
                changesList.innerHTML = '';
                
                changes.forEach(change => {
                    const item = document.createElement('div');
                    item.className = 'change-item';
                    item.innerHTML = `<strong>${change.wrong}</strong> â†’ <strong>${change.correct}</strong> (${change.count}ç®‡æ‰€)`;
                    changesList.appendChild(item);
                });

                if (regexChanges) {
                    regexChanges.forEach(change => {
                        const item = document.createElement('div');
                        item.className = 'change-item regex-change-item';
                        item.innerHTML = `[æ­£è¦åŒ–] <strong>${change.description}</strong> (${change.count}ç®‡æ‰€)`;
                        changesList.appendChild(item);
                    });
                }
            } else {
                changesContainer.style.display = 'none';
            }
        }

        function updateStats(changes, fileCount, regexCount) {
            const totalChanges = changes.reduce((sum, change) => sum + (change.count || 1), 0);
            document.getElementById('total-changes').textContent = totalChanges;
            document.getElementById('files-processed').textContent = fileCount;
            document.getElementById('unique-corrections').textContent = changes.length;
            document.getElementById('regex-corrections').textContent = regexCount;
        }

        function downloadResult() {
            const result = document.getElementById('output-text').value;
            if (result) {
                const blob = new Blob([result], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `corrected_text_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        function copyToClipboard() {
            const result = document.getElementById('output-text').value;
            if (result) {
                navigator.clipboard.writeText(result).then(() => {
                    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                }).catch(() => {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    const textArea = document.createElement('textarea');
                    textArea.value = result;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                });
            }
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            corrector.updatePreview();
        });
    </script>
</body>
</html>